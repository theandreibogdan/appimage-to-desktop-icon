#!/usr/bin/env bash

# Set strict error handling
set -euo pipefail

# Version
VERSION="1.2.2"

# Color definitions
setup_colors() {
    # Only use colors if connected to a terminal
    if [ -t 1 ]; then
        RED=$(printf '\033[31m')
        GREEN=$(printf '\033[32m')
        YELLOW=$(printf '\033[33m')
        BLUE=$(printf '\033[34m')
        BOLD=$(printf '\033[1m')
        RESET=$(printf '\033[0m')
    else
        RED=""
        GREEN=""
        YELLOW=""
        BLUE=""
        BOLD=""
        RESET=""
    fi
}

# Initialize colors
setup_colors

# Base directories following XDG specification
USER_APPS_DIR="${HOME}/.local/bin"
USER_ICONS_DIR="${HOME}/.local/share/icons/hicolor"
USER_DESKTOP_DIR="${HOME}/.local/share/applications"

ROOT_APPS_DIR="/usr/local/bin"
ROOT_ICONS_DIR="/usr/share/icons/hicolor"
ROOT_DESKTOP_DIR="/usr/share/applications"

# Function to display usage information
show_help() {
    printf "\n"
    printf "%s\n" "AppImage to Desktop Icon - Version ${VERSION}"
    printf "\n"
    printf "%s\n" "${YELLOW}Usage:${RESET}"
    printf "    appimage [OPTIONS] <path_to_appimage> <path_to_icon>\n"
    printf "    appimage remove <app_name>\n"
    printf "    appimage list\n"
    printf "    appimage uninstall\n"
    printf "\n"
    printf "%s\n" "${YELLOW}Options:${RESET}"
    printf "    -h, --help     Show this help message\n"
    printf "    -v, --version  Show version information\n"
    printf "    --root         Install the application system-wide (requires sudo)\n"
    printf "    remove         Remove an installed AppImage application\n"
    printf "    list           List all installed AppImage applications\n"
    printf "    uninstall      Remove the appimage tool from your system\n"
    printf "\n"
    printf "%s\n" "${YELLOW}Examples:${RESET}"
    printf "    appimage ~/Downloads/MyApp.AppImage ~/Downloads/icon.png\n"
    printf "    sudo appimage --root ~/Downloads/MyApp.AppImage ~/Downloads/icon.png\n"
    printf "    appimage list\n"
    printf "    appimage remove MyApp\n"
    printf "    sudo appimage --root remove MyApp\n"
    printf "    appimage uninstall\n"
    printf "\n"
    printf "%s\n" "${YELLOW}Description:${RESET}"
    printf "    This tool integrates AppImage applications into your Linux desktop environment\n"
    printf "    by creating the necessary desktop entries and handling icon integration.\n"
    printf "\n"
}

# Function to show version
show_version() {
    printf "%s\n" "${BLUE}AppImage to Desktop Icon${RESET} - Version ${VERSION}"
}

# Function to log messages
log() {
    local level=$1
    shift
    case "$level" in
        "error")   printf "%s%s%s\n" "${RED}[ERROR]${RESET}" " " "$*" >&2 ;;
        "info")    printf "%s%s%s\n" "${GREEN}[INFO]${RESET}" " " "$*" ;;
        "warning") printf "%s%s%s\n" "${YELLOW}[WARNING]${RESET}" " " "$*" ;;
    esac
}

# Function to check if running as root
check_root() {
    if [[ $EUID -ne 0 ]]; then
        log "error" "Root installation requires sudo privileges. Please run with: sudo appimage --root ..."
        exit 1
    fi
}

# Function to validate file existence and permissions
validate_file() {
    local file=$1
    local type=$2
    
    if [[ ! -f "$file" ]]; then
        log "error" "The $type file '$file' does not exist."
        exit 1
    fi
    
    if [[ ! -r "$file" ]]; then
        log "error" "The $type file '$file' is not readable."
        exit 1
    fi
}

# Function to create necessary directories
create_directories() {
    local is_root=$1
    local apps_dir icons_dir desktop_dir

    if [[ "$is_root" == "true" ]]; then
        apps_dir="${ROOT_APPS_DIR}"
        icons_dir="${ROOT_ICONS_DIR}"
        desktop_dir="${ROOT_DESKTOP_DIR}"
        
        # Ensure root ownership and proper permissions
        mkdir -p "${apps_dir}"
        mkdir -p "${icons_dir}/scalable/apps"
        mkdir -p "${icons_dir}/128x128/apps"
        mkdir -p "${desktop_dir}"
        
        chown root:root "${apps_dir}"
        chown -R root:root "${icons_dir}"
        chown root:root "${desktop_dir}"
        
        chmod 755 "${apps_dir}"
        chmod -R 755 "${icons_dir}"
        chmod 755 "${desktop_dir}"
    else
        apps_dir="${USER_APPS_DIR}"
        icons_dir="${USER_ICONS_DIR}"
        desktop_dir="${USER_DESKTOP_DIR}"
        
        mkdir -p "${apps_dir}"
        mkdir -p "${icons_dir}/scalable/apps"
        mkdir -p "${icons_dir}/128x128/apps"
        mkdir -p "${desktop_dir}"
    fi
}

# Function to get icon size and format
get_icon_info() {
    local icon_path=$1
    local mime_type
    mime_type=$(file --mime-type -b "$icon_path")
    
    case "$mime_type" in
        "image/svg"*) echo "scalable" ;;
        "image/png"|"image/jpeg") 
            # For now, we'll put all bitmap images in 128x128
            echo "128x128" ;;
        *)
            log "error" "Unsupported icon format: $mime_type"
            exit 1 ;;
    esac
}

# Function to install the AppImage
install_appimage() {
    local appimage_path=$1
    local is_root=$2
    local app_name apps_dir target_path
    
    app_name=$(basename "$appimage_path" .AppImage)
    apps_dir=$(if [[ "$is_root" == "true" ]]; then echo "${ROOT_APPS_DIR}"; else echo "${USER_APPS_DIR}"; fi)
    target_path="${apps_dir}/${app_name}"
    
    cp "$appimage_path" "$target_path"
    chmod +x "$target_path"
    echo "$target_path"
}

# Function to install the icon
install_icon() {
    local icon_path=$1
    local app_name=$2
    local is_root=$3
    local icon_size icons_dir
    
    icon_size=$(get_icon_info "$icon_path")
    icons_dir=$(if [[ "$is_root" == "true" ]]; then echo "${ROOT_ICONS_DIR}"; else echo "${USER_ICONS_DIR}"; fi)
    
    local icon_ext="${icon_path##*.}"
    local target_path="${icons_dir}/${icon_size}/apps/${app_name}.${icon_ext}"
    
    cp "$icon_path" "$target_path"
    echo "$app_name.${icon_ext}"
}

# Function to create desktop entry
create_desktop_entry() {
    local app_path=$1
    local icon_name=$2
    local is_root=$3
    local app_name desktop_dir desktop_file
    
    app_name=$(basename "$app_path" .AppImage)
    desktop_dir=$(if [[ "$is_root" == "true" ]]; then echo "${ROOT_DESKTOP_DIR}"; else echo "${USER_DESKTOP_DIR}"; fi)
    desktop_file="${desktop_dir}/${app_name}.desktop"
    
    # Get application name from AppImage if possible
    local display_name
    if [ -x "$app_path" ]; then
        display_name=$("$app_path" --appimage-offset >/dev/null 2>&1 && "$app_path" --name 2>/dev/null || echo "$app_name")
    else
        display_name="$app_name"
    fi
    
    cat > "$desktop_file" << EOF
[Desktop Entry]
Name=${display_name}
Exec=${app_path}
Icon=${icon_name}
Type=Application
Categories=Application;
Terminal=false
StartupNotify=true
EOF

    chmod +x "$desktop_file"

    # Update desktop database
    if [[ "$is_root" == "true" ]]; then
        update-desktop-database "${ROOT_DESKTOP_DIR}" &>/dev/null || true
        for theme_dir in "${ROOT_ICONS_DIR}"/*; do
            if [ -d "$theme_dir" ]; then
                gtk-update-icon-cache -f -t "$theme_dir" &>/dev/null || true
            fi
        done
    else
        update-desktop-database "${USER_DESKTOP_DIR}" &>/dev/null || true
        for theme_dir in "${USER_ICONS_DIR}"/*; do
            if [ -d "$theme_dir" ]; then
                gtk-update-icon-cache -f -t "$theme_dir" &>/dev/null || true
            fi
        done
    fi

    # Refresh desktop environment
    refresh_desktop_environment
}

# Function to list installed applications
list_applications() {
    local is_root=$1
    local apps_dir desktop_dir
    local found=false
    
    if [[ "$is_root" == "true" ]]; then
        apps_dir="${ROOT_APPS_DIR}"
        desktop_dir="${ROOT_DESKTOP_DIR}"
    else
        apps_dir="${USER_APPS_DIR}"
        desktop_dir="${USER_DESKTOP_DIR}"
    fi

    printf "\n%s\n" "${BLUE}Installed AppImage Applications:${RESET}"
    printf "%s\n" "${YELLOW}Location: ${apps_dir}${RESET}"
    printf "%s\n" "----------------------------------------"

    # Check .desktop files for installed applications
    if [[ -d "$desktop_dir" ]]; then
        while IFS= read -r -d '' desktop_file; do
            if grep -q "Exec=.*AppImage\|Exec=${apps_dir}" "$desktop_file"; then
                local app_name
                app_name=$(basename "$desktop_file" .desktop)
                if [[ -f "${apps_dir}/${app_name}" ]]; then
                    printf "ðŸ“¦ %s\n" "$app_name"
                    found=true
                fi
            fi
        done < <(find "$desktop_dir" -name "*.desktop" -print0)
    fi

    if [[ "$found" == "false" ]]; then
        printf "No AppImage applications installed %s\n" "$(if [[ "$is_root" == "true" ]]; then echo "system-wide"; else echo "for current user"; fi)"
    fi
    printf "\n"
}

# Function to uninstall application
uninstall_app() {
    local app_name=$1
    local is_root=$2
    local apps_dir icons_dir desktop_dir success=false
    
    # Prevent accidental removal of the tool itself
    if [[ "$app_name" == "appimage" ]]; then
        log "error" "Cannot remove the tool itself. Use 'appimage uninstall' instead."
        exit 1
    fi
    
    if [[ "$is_root" == "true" ]]; then
        apps_dir="${ROOT_APPS_DIR}"
        icons_dir="${ROOT_ICONS_DIR}"
        desktop_dir="${ROOT_DESKTOP_DIR}"
    else
        apps_dir="${USER_APPS_DIR}"
        icons_dir="${USER_ICONS_DIR}"
        desktop_dir="${USER_DESKTOP_DIR}"
    fi

    # Remove AppImage
    if [[ -f "${apps_dir}/${app_name}" ]]; then
        rm -f "${apps_dir}/${app_name}"
        success=true
        log "info" "Removed AppImage from ${apps_dir}/${app_name}"
    fi

    # Remove desktop entry
    if [[ -f "${desktop_dir}/${app_name}.desktop" ]]; then
        rm -f "${desktop_dir}/${app_name}.desktop"
        success=true
        log "info" "Removed desktop entry from ${desktop_dir}/${app_name}.desktop"
    fi

    # Remove icons (try both PNG and SVG)
    for size in "scalable" "128x128"; do
        for ext in "png" "svg"; do
            if [[ -f "${icons_dir}/${size}/apps/${app_name}.${ext}" ]]; then
                rm -f "${icons_dir}/${size}/apps/${app_name}.${ext}"
                success=true
                log "info" "Removed icon from ${icons_dir}/${size}/apps/${app_name}.${ext}"
            fi
        done
    done

    # Update desktop database
    if [[ "$success" == "true" ]]; then
        if [[ "$is_root" == "true" ]]; then
            update-desktop-database "${ROOT_DESKTOP_DIR}" &>/dev/null || true
            gtk-update-icon-cache -f -t "${ROOT_ICONS_DIR}" &>/dev/null || true
        else
            update-desktop-database "${USER_DESKTOP_DIR}" &>/dev/null || true
            gtk-update-icon-cache -f -t "${USER_ICONS_DIR}" &>/dev/null || true
        fi
        log "info" "Application '${app_name}' has been removed successfully!"
        log "warning" "You may need to log out and log back in for the changes to take effect in your application menu."
    else
        log "error" "No files found for application '${app_name}'. Make sure the name is correct and it was installed with this tool."
        log "info" "Use 'appimage list' to see all installed applications."
        exit 1
    fi
}

# Function to remove the tool itself
remove_tool() {
    local script_path
    script_path=$(which appimage)
    
    if [[ -z "$script_path" ]]; then
        log "error" "Could not find the appimage tool in your PATH"
        exit 1
    fi
    
    # Check if the script is in a system directory
    if [[ "$script_path" == "/usr/"* ]] || [[ "$script_path" == "/opt/"* ]]; then
        if [[ $EUID -ne 0 ]]; then
            log "error" "The tool is installed system-wide. Please run: sudo appimage uninstall"
            exit 1
        fi
    fi
    
    # Remove the script
    rm -f "$script_path"
    log "info" "Removed appimage tool from: $script_path"
    
    # Check if we need to clean up PATH in .bashrc
    if grep -q "export PATH=\"\$PATH:${HOME}/.local/bin\"" ~/.bashrc; then
        # Only remove the PATH if .local/bin is empty
        if [[ ! -d "${HOME}/.local/bin" ]] || [[ -z "$(ls -A "${HOME}/.local/bin")" ]]; then
            sed -i '/export PATH="\$PATH:${HOME}\/.local\/bin"/d' ~/.bashrc
            log "info" "Removed .local/bin from PATH in .bashrc"
            log "info" "Please run: source ~/.bashrc to apply changes"
        fi
    fi
    
    log "info" "The appimage tool has been successfully removed from your system."
}

# Function to detect desktop environment
detect_desktop_environment() {
    if [ -n "${XDG_CURRENT_DESKTOP:-}" ]; then
        echo "$XDG_CURRENT_DESKTOP"
    elif [ -n "${DESKTOP_SESSION:-}" ]; then
        echo "$DESKTOP_SESSION"
    else
        echo "unknown"
    fi
}

# Function to refresh desktop environment
refresh_desktop_environment() {
    local de
    de=$(detect_desktop_environment | tr '[:upper:]' '[:lower:]')
    
    case "$de" in
        *kde*|*plasma*)
            if command -v plasmashell >/dev/null 2>&1; then
                killall plasmashell 2>/dev/null
                nohup plasmashell >/dev/null 2>&1 &
            fi
            ;;
        *gnome*|*unity*)
            if command -v gnome-shell >/dev/null 2>&1; then
                killall -HUP gnome-shell 2>/dev/null
            fi
            ;;
        *xfce*)
            if command -v xfdesktop >/dev/null 2>&1; then
                xfdesktop --reload 2>/dev/null
            fi
            ;;
        *cinnamon*)
            if command -v cinnamon >/dev/null 2>&1; then
                killall -HUP cinnamon-launcher 2>/dev/null
            fi
            ;;
        *mate*)
            if command -v mate-panel >/dev/null 2>&1; then
                mate-panel --replace & 2>/dev/null
            fi
            ;;
        *)
            log "warning" "Unknown desktop environment. Manual refresh may be required."
            ;;
    esac
}

# Add this function near the top of the file, after the color definitions
check_and_elevate_privileges() {
    if [[ $EUID -ne 0 ]]; then
        log "info" "Root privileges required. Requesting sudo access..."
        if ! command -v sudo >/dev/null 2>&1; then
            log "error" "sudo is not installed. Please install sudo or run this command as root."
            exit 1
        fi
        exec sudo "$0" "$@"
    fi
}

# Main script logic
main() {
    local is_root=false
    
    # Check if no arguments provided
    if [[ $# -eq 0 ]]; then
        log "error" "No arguments provided."
        show_help
        exit 1
    fi

    # Parse command line arguments
    case "$1" in
        -h|--help)
            show_help
            exit 0
            ;;
        -v|--version)
            show_version
            exit 0
            ;;
        --root)
            is_root=true
            check_and_elevate_privileges "$@"
            shift
            if [[ $# -eq 0 ]]; then
                log "error" "No arguments provided after --root"
                show_help
                exit 1
            fi
            ;;
        list)
            list_applications "$is_root"
            exit 0
            ;;
        remove)
            if [[ $# -ne 2 ]]; then
                log "error" "Please provide the application name to remove."
                printf "\n%s\n" "${YELLOW}Usage:${RESET} appimage remove <app_name>"
                log "info" "Use 'appimage list' to see all installed applications."
                exit 1
            fi
            if [[ "$is_root" == "true" ]]; then
                check_and_elevate_privileges "$@"
            fi
            uninstall_app "$2" "$is_root"
            exit 0
            ;;
        uninstall)
            if [[ $# -ne 1 ]]; then
                log "error" "The uninstall command doesn't take any additional arguments."
                printf "\n%s\n" "${YELLOW}Usage:${RESET} appimage uninstall"
                exit 1
            fi
            if [[ "$is_root" == "true" ]]; then
                check_and_elevate_privileges "$@"
            fi
            remove_tool
            exit 0
            ;;
        *)
            # Handle installation case
            if [[ $1 == -* ]]; then
                log "error" "Unknown option: $1"
                show_help
                exit 1
            fi
            ;;
    esac

    # If we get here, we're doing an installation
    if [[ $# -ne 2 ]]; then
        log "error" "Incorrect number of arguments for installation."
        printf "\n%s\n" "${YELLOW}Usage:${RESET} appimage [--root] <path_to_appimage> <path_to_icon>"
        exit 1
    fi

    local appimage_path=$1
    local icon_path=$2

    # Validate input files
    validate_file "$appimage_path" "AppImage"
    validate_file "$icon_path" "icon"

    # Create necessary directories
    log "info" "Creating required directories..."
    create_directories "$is_root"

    # Install AppImage
    log "info" "Installing AppImage..."
    local installed_app_path
    installed_app_path=$(install_appimage "$appimage_path" "$is_root")

    # Install icon
    log "info" "Installing icon..."
    local installed_icon_name
    installed_icon_name=$(install_icon "$icon_path" "$(basename "$appimage_path" .AppImage)" "$is_root")

    # Create desktop entry
    log "info" "Creating desktop entry..."
    create_desktop_entry "$installed_app_path" "$installed_icon_name" "$is_root"

    log "info" "Installation completed successfully!"
    log "info" "The application has been installed and should appear in your applications menu."
    log "warning" "If you don't see the application immediately, try one of these steps:"
    log "info" "1. Wait a few seconds for the desktop environment to refresh"
    log "info" "2. Log out and log back in"
    log "info" "3. Run: killall plasmashell && plasmashell & (for KDE)"
    log "info" "4. Run: killall gnome-shell (for GNOME, press ALT+F2, type 'r' and press Enter)"
}

# Execute main function
main "$@" 