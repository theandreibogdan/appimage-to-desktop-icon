#!/usr/bin/env bash

# Set strict error handling
set -euo pipefail

# Version
VERSION="1.1.3"

# Color definitions
setup_colors() {
    # Only use colors if connected to a terminal
    if [ -t 1 ]; then
        RED=$(printf '\033[31m')
        GREEN=$(printf '\033[32m')
        YELLOW=$(printf '\033[33m')
        BLUE=$(printf '\033[34m')
        BOLD=$(printf '\033[1m')
        RESET=$(printf '\033[0m')
    else
        RED=""
        GREEN=""
        YELLOW=""
        BLUE=""
        BOLD=""
        RESET=""
    fi
}

# Initialize colors
setup_colors

# Base directories following XDG specification
USER_APPS_DIR="${HOME}/.local/bin"
USER_ICONS_DIR="${HOME}/.local/share/icons/hicolor"
USER_DESKTOP_DIR="${HOME}/.local/share/applications"

ROOT_APPS_DIR="/usr/local/bin"
ROOT_ICONS_DIR="/usr/share/icons/hicolor"
ROOT_DESKTOP_DIR="/usr/share/applications"

# Function to display usage information
show_help() {
    printf "\n"
    printf "%s\n" "${BLUE}AppImage to Desktop Icon${RESET} - Version ${VERSION}"
    printf "\n"
    printf "%s\n" "${YELLOW}Usage:${RESET}"
    printf "    appimage [OPTIONS] <path_to_appimage> <path_to_icon>\n"
    printf "    appimage uninstall <app_name>\n"
    printf "    appimage remove\n"
    printf "\n"
    printf "%s\n" "${YELLOW}Options:${RESET}"
    printf "    -h, --help     Show this help message\n"
    printf "    -v, --version  Show version information\n"
    printf "    --root         Install the application system-wide (requires sudo)\n"
    printf "    uninstall      Remove an installed AppImage application\n"
    printf "    remove         Remove the appimage tool from your system\n"
    printf "\n"
    printf "%s\n" "${YELLOW}Examples:${RESET}"
    printf "    appimage ~/Downloads/MyApp.AppImage ~/Downloads/icon.png\n"
    printf "    sudo appimage --root ~/Downloads/MyApp.AppImage ~/Downloads/icon.png\n"
    printf "    appimage uninstall MyApp\n"
    printf "    sudo appimage --root uninstall MyApp\n"
    printf "    appimage remove\n"
    printf "\n"
    printf "%s\n" "${YELLOW}Description:${RESET}"
    printf "    This tool integrates AppImage applications into your Linux desktop environment\n"
    printf "    by creating the necessary desktop entries and handling icon integration.\n"
    printf "\n"
}

# Function to show version
show_version() {
    printf "%s\n" "${BLUE}AppImage to Desktop Icon${RESET} - Version ${VERSION}"
}

# Function to log messages
log() {
    local level=$1
    shift
    case "$level" in
        "error")   printf "%s%s%s\n" "${RED}[ERROR]${RESET}" " " "$*" >&2 ;;
        "info")    printf "%s%s%s\n" "${GREEN}[INFO]${RESET}" " " "$*" ;;
        "warning") printf "%s%s%s\n" "${YELLOW}[WARNING]${RESET}" " " "$*" ;;
    esac
}

# Function to check if running as root
check_root() {
    if [[ $EUID -ne 0 ]]; then
        log "error" "Root installation requires sudo privileges. Please run with: sudo appimage --root ..."
        exit 1
    fi
}

# Function to validate file existence and permissions
validate_file() {
    local file=$1
    local type=$2
    
    if [[ ! -f "$file" ]]; then
        log "error" "The $type file '$file' does not exist."
        exit 1
    fi
    
    if [[ ! -r "$file" ]]; then
        log "error" "The $type file '$file' is not readable."
        exit 1
    fi
}

# Function to create necessary directories
create_directories() {
    local is_root=$1
    local apps_dir icons_dir desktop_dir

    if [[ "$is_root" == "true" ]]; then
        apps_dir="${ROOT_APPS_DIR}"
        icons_dir="${ROOT_ICONS_DIR}"
        desktop_dir="${ROOT_DESKTOP_DIR}"
    else
        apps_dir="${USER_APPS_DIR}"
        icons_dir="${USER_ICONS_DIR}"
        desktop_dir="${USER_DESKTOP_DIR}"
    fi

    mkdir -p "${apps_dir}"
    mkdir -p "${icons_dir}/scalable/apps"
    mkdir -p "${icons_dir}/128x128/apps"
    mkdir -p "${desktop_dir}"
}

# Function to get icon size and format
get_icon_info() {
    local icon_path=$1
    local mime_type
    mime_type=$(file --mime-type -b "$icon_path")
    
    case "$mime_type" in
        "image/svg"*) echo "scalable" ;;
        "image/png"|"image/jpeg") 
            # For now, we'll put all bitmap images in 128x128
            echo "128x128" ;;
        *)
            log "error" "Unsupported icon format: $mime_type"
            exit 1 ;;
    esac
}

# Function to install the AppImage
install_appimage() {
    local appimage_path=$1
    local is_root=$2
    local app_name apps_dir target_path
    
    app_name=$(basename "$appimage_path" .AppImage)
    apps_dir=$(if [[ "$is_root" == "true" ]]; then echo "${ROOT_APPS_DIR}"; else echo "${USER_APPS_DIR}"; fi)
    target_path="${apps_dir}/${app_name}"
    
    cp "$appimage_path" "$target_path"
    chmod +x "$target_path"
    echo "$target_path"
}

# Function to install the icon
install_icon() {
    local icon_path=$1
    local app_name=$2
    local is_root=$3
    local icon_size icons_dir
    
    icon_size=$(get_icon_info "$icon_path")
    icons_dir=$(if [[ "$is_root" == "true" ]]; then echo "${ROOT_ICONS_DIR}"; else echo "${USER_ICONS_DIR}"; fi)
    
    local icon_ext="${icon_path##*.}"
    local target_path="${icons_dir}/${icon_size}/apps/${app_name}.${icon_ext}"
    
    cp "$icon_path" "$target_path"
    echo "$app_name.${icon_ext}"
}

# Function to create desktop entry
create_desktop_entry() {
    local app_path=$1
    local icon_name=$2
    local is_root=$3
    local app_name desktop_dir desktop_file
    
    app_name=$(basename "$app_path" .AppImage)
    desktop_dir=$(if [[ "$is_root" == "true" ]]; then echo "${ROOT_DESKTOP_DIR}"; else echo "${USER_DESKTOP_DIR}"; fi)
    desktop_file="${desktop_dir}/${app_name}.desktop"
    
    cat > "$desktop_file" << EOF
[Desktop Entry]
Name=${app_name}
Exec=${app_path}
Icon=${icon_name}
Type=Application
Categories=Application;
Terminal=false
EOF

    # Update desktop database
    if [[ "$is_root" == "true" ]]; then
        update-desktop-database "${ROOT_DESKTOP_DIR}" &>/dev/null || true
        gtk-update-icon-cache -f -t "${ROOT_ICONS_DIR}" &>/dev/null || true
    else
        update-desktop-database "${USER_DESKTOP_DIR}" &>/dev/null || true
        gtk-update-icon-cache -f -t "${USER_ICONS_DIR}" &>/dev/null || true
    fi
}

# Function to uninstall application
uninstall_app() {
    local app_name=$1
    local is_root=$2
    local apps_dir icons_dir desktop_dir success=false
    
    # Prevent accidental removal of the tool itself
    if [[ "$app_name" == "appimage" ]]; then
        log "error" "Cannot uninstall the tool itself. Use 'appimage remove' instead."
        exit 1
    }
    
    if [[ "$is_root" == "true" ]]; then
        apps_dir="${ROOT_APPS_DIR}"
        icons_dir="${ROOT_ICONS_DIR}"
        desktop_dir="${ROOT_DESKTOP_DIR}"
    else
        apps_dir="${USER_APPS_DIR}"
        icons_dir="${USER_ICONS_DIR}"
        desktop_dir="${USER_DESKTOP_DIR}"
    fi

    # Remove AppImage
    if [[ -f "${apps_dir}/${app_name}" ]]; then
        rm -f "${apps_dir}/${app_name}"
        success=true
        log "info" "Removed AppImage from ${apps_dir}/${app_name}"
    fi

    # Remove desktop entry
    if [[ -f "${desktop_dir}/${app_name}.desktop" ]]; then
        rm -f "${desktop_dir}/${app_name}.desktop"
        success=true
        log "info" "Removed desktop entry from ${desktop_dir}/${app_name}.desktop"
    fi

    # Remove icons (try both PNG and SVG)
    for size in "scalable" "128x128"; do
        for ext in "png" "svg"; do
            if [[ -f "${icons_dir}/${size}/apps/${app_name}.${ext}" ]]; then
                rm -f "${icons_dir}/${size}/apps/${app_name}.${ext}"
                success=true
                log "info" "Removed icon from ${icons_dir}/${size}/apps/${app_name}.${ext}"
            fi
        done
    done

    # Update desktop database
    if [[ "$success" == "true" ]]; then
        if [[ "$is_root" == "true" ]]; then
            update-desktop-database "${ROOT_DESKTOP_DIR}" &>/dev/null || true
            gtk-update-icon-cache -f -t "${ROOT_ICONS_DIR}" &>/dev/null || true
        else
            update-desktop-database "${USER_DESKTOP_DIR}" &>/dev/null || true
            gtk-update-icon-cache -f -t "${USER_ICONS_DIR}" &>/dev/null || true
        fi
        log "info" "Application '${app_name}' has been uninstalled successfully!"
        log "warning" "You may need to log out and log back in for the changes to take effect in your application menu."
    else
        log "error" "No files found for application '${app_name}'. Make sure the name is correct and it was installed with this tool."
        exit 1
    fi
}

# Function to remove the tool itself
remove_tool() {
    local script_path
    script_path=$(which appimage)
    
    if [[ -z "$script_path" ]]; then
        log "error" "Could not find the appimage tool in your PATH"
        exit 1
    fi
    
    # Check if the script is in a system directory
    if [[ "$script_path" == "/usr/"* ]] || [[ "$script_path" == "/opt/"* ]]; then
        if [[ $EUID -ne 0 ]]; then
            log "error" "The tool is installed system-wide. Please run: sudo appimage remove"
            exit 1
        fi
    fi
    
    # Remove the script
    rm -f "$script_path"
    log "info" "Removed appimage tool from: $script_path"
    
    # Check if we need to clean up PATH in .bashrc
    if grep -q "export PATH=\"\$PATH:${HOME}/.local/bin\"" ~/.bashrc; then
        # Only remove the PATH if .local/bin is empty
        if [[ ! -d "${HOME}/.local/bin" ]] || [[ -z "$(ls -A "${HOME}/.local/bin")" ]]; then
            sed -i '/export PATH="\$PATH:${HOME}\/.local\/bin"/d' ~/.bashrc
            log "info" "Removed .local/bin from PATH in .bashrc"
            log "info" "Please run: source ~/.bashrc to apply changes"
        fi
    fi
    
    log "info" "The appimage tool has been successfully removed from your system."
}

# Main script logic
main() {
    local is_root=false
    
    # Check if no arguments provided
    if [[ $# -eq 0 ]]; then
        log "error" "No arguments provided."
        show_help
        exit 1
    fi

    # Parse command line arguments
    case "$1" in
        -h|--help)
            show_help
            exit 0
            ;;
        -v|--version)
            show_version
            exit 0
            ;;
        --root)
            is_root=true
            check_root
            shift
            if [[ $# -eq 0 ]]; then
                log "error" "No arguments provided after --root"
                show_help
                exit 1
            fi
            ;;
        uninstall)
            if [[ $# -ne 2 ]]; then
                log "error" "Please provide the application name to uninstall."
                printf "\n%s\n" "${YELLOW}Usage:${RESET} appimage uninstall <app_name>"
                exit 1
            fi
            uninstall_app "$2" "$is_root"
            exit 0
            ;;
        remove)
            if [[ $# -ne 1 ]]; then
                log "error" "The remove command doesn't take any additional arguments."
                printf "\n%s\n" "${YELLOW}Usage:${RESET} appimage remove"
                exit 1
            fi
            remove_tool
            exit 0
            ;;
        *)
            # Handle installation case
            if [[ $1 == -* ]]; then
                log "error" "Unknown option: $1"
                show_help
                exit 1
            fi
            ;;
    esac

    # If we get here, we're doing an installation
    if [[ $# -ne 2 ]]; then
        log "error" "Incorrect number of arguments for installation."
        printf "\n%s\n" "${YELLOW}Usage:${RESET} appimage [--root] <path_to_appimage> <path_to_icon>"
        exit 1
    fi

    local appimage_path=$1
    local icon_path=$2

    # Validate input files
    validate_file "$appimage_path" "AppImage"
    validate_file "$icon_path" "icon"

    # Create necessary directories
    log "info" "Creating required directories..."
    create_directories "$is_root"

    # Install AppImage
    log "info" "Installing AppImage..."
    local installed_app_path
    installed_app_path=$(install_appimage "$appimage_path" "$is_root")

    # Install icon
    log "info" "Installing icon..."
    local installed_icon_name
    installed_icon_name=$(install_icon "$icon_path" "$(basename "$appimage_path" .AppImage)" "$is_root")

    # Create desktop entry
    log "info" "Creating desktop entry..."
    create_desktop_entry "$installed_app_path" "$installed_icon_name" "$is_root"

    log "info" "Installation completed successfully!"
    log "info" "The application has been installed and should appear in your applications menu."
    log "warning" "If you don't see the application immediately, try one of these steps:"
    log "info" "1. Wait a few seconds for the desktop environment to refresh"
    log "info" "2. Log out and log back in"
    log "info" "3. Run: killall plasmashell && plasmashell & (for KDE)"
    log "info" "4. Run: killall gnome-shell (for GNOME, press ALT+F2, type 'r' and press Enter)"
}

# Execute main function
main "$@" 